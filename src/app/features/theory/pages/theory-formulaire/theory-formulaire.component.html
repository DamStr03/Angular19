<theory-header chapterName="Formulaire" />
<section class="card-body">
	<article class="card">
		<div class="card-header">
			<h2 class="card-title">Diff√©rents formulaires</h2>
		</div>
		<div class="card-body">
			<p>En Angular, il existe 2 types de formulaires:</p>
			<ul>
				<li>
					<p>
						<strong>Template-driven Forms</strong>: Cest formulaire utilisent le <code>Two-way binding</code> pour les entr√©es
						de l'utilisateur. Ils sont plus simples √† mettre en place et sont g√©n√©ralement utilis√©s pour des formulaires
						simples. <br />
						Mais ne poss√®dent pas de validation avanc√©e. <br />
						<span [ngStyle]="{color: 'red'}"
							>Rappel: Il est n√©cessaire d'importer <code>FormsModule</code> dans le composant</span
						>
					</p>
				</li>
				<li>
					<p>
						<strong>Reactive Forms</strong> : Ces formulaires permettent de g√©rer des groupes de contr√¥les de mani√®re r√©active
						et de valider les champs de formulaire plus efficacement. <br />
						<span [ngStyle]="{color: 'red'}">
							Rappel: Il est n√©cessaire d'importer <code>ReactiveFormsModule</code> dans le composant
						</span>
					</p>
				</li>
			</ul>
			<hr />
			<p>
				Dans ce chapitre, nous privil√©gierons l'utilisation des <strong>Reactive Forms</strong> pour leur flexibilit√© et leur
				puissance.
			</p>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2 class="card-title">FormBuilder</h2>
		</div>
		<div class="card-body">
			<p>
				La classe int√©gr√©e √† Angular, <code>FormBuilder</code>, nous permet de d√©clarer facilement nos formulaires r√©actifs. Pour
				l'utiliser, nous devons l'injecter dans le constructeur de notre composant.
				<textarea highlight-js [options]="{}" [lang]="'typescript'">
import {Component, inject} from "@angular/core";
import {FormBuilder} from "@angular/forms"; // 1. importer la classe FormBuilder

@Component({
  selector: "demo-formulaire",
  imports: [],
  templateUrl: "./demo-formulaire.component.html",
  styleUrl: "./demo-formulaire.component.scss",
})
export class DemoFormulaireComponent {
  private readonly _fb = inject(FormBuilder); // 2. injection de FormBuilder
}
				</textarea
				>
			</p>
			<p>Une fois que FormBuilder est inject√©, nous pouvons cr√©er des FormControl et des FormGroup de mani√®re concise.</p>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>FormGroup</h2>
		</div>
		<div class="card-body">
			<p>
				Un <code>FormGroup</code> est un groupe de contr√¥les de formulaire. Il nous permet de g√©rer plusieurs champs de saisie en
				m√™me temps. Nous pouvons cr√©er un <code>FormGroup</code> en utilisant la m√©thode <code>group()</code> de
				<code>FormBuilder</code>.
			</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
import {Component, inject} from "@angular/core";
import {FormBuilder} from "@angular/forms";

@Component({
  selector: "demo-formulaire",
  imports: [],
  templateUrl: "./demo-formulaire.component.html",
  styleUrl: "./demo-formulaire.component.scss",
})
export class DemoFormulaireComponent {
  private readonly _fb = inject(FormBuilder);

  // Formulaire de contact
  contactForm = this._fb.group({ // cr√©ation du formGroup
    /* on va mettre nos champs ici */
  });
}
			</textarea
			>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2 class="card-title">FormControl</h2>
		</div>
		<div class="card-body">
			<p>
				Un <code>FormControl</code> repr√©sente un champ de formulaire individuel. Il peut √™tre utilis√© pour g√©rer la valeur et
				l'√©tat de validation d'un champ de saisie.
			</p>
			<p>
				Nous pouvons cr√©er un <code>FormControl</code> en utilisant la m√©thode <code>control()</code> de <code>FormBuilder</code>.
				Cette m√©thode prend en param√®tre la valeur initiale du contr√¥le et un tableau d'options.
			</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
// Formulaire de contact
contactForm = this._fb.group({
  email: new FormControl(""), // synthaxe complete explicite
  firstName: this._fb.control(""), // synthaxe complete
  lastName: [""], // synthaxe simplifi√©e
});
			</textarea
			>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>Formulaire HTML</h2>
		</div>
		<div class="card-body">
			<p>
				Le formulaire c√¥t√© HTML ne change pas mais il faut juste rajouter le <code>[formGroup]</code> dans la balise
				<code>form</code> et <code>formControlName</code> dans chaque champ de saisie.
			</p>
			<p>
				Cela nous permet de li√© le formulaire HTML au formGroup qui se trouve dans notre fichier ts <br />
				<i
					>‚ö†Ô∏è la valeur de <code>formControlName</code> doit correspondre avec le nom des propri√©t√©s que l'on a √©crit dans le
					<code>formGroup</code> du fichier TS</i
				>
			</p>
			<textarea highlight-js [options]="{}" [lang]="'html'">
<form [formGroup]="contactForm">  <!-- On rajoute [formGroup] -->
<div>
  <label for="email">Email</label>
  <input id="email" type="text" formControlName="email" placeholder="Email" /> <!-- On rajoute formControlName -->
</div>
<div>
  <label for="firstName">FirstName:</label>
  <input id="firstName" type="text" formControlName="firstName" placeholder="FirstName" /> <!-- On rajoute formControlName -->
</div>
<div>
  <label for="lastName">LastName:</label>
  <input id="lastName" type="text" formControlName="lastName" placeholder="LastName" /> <!-- On rajoute formControlName -->
</div>
<button type="submit">Envoyer</button>
</form>
			</textarea
			>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2 class="card-title">Validators</h2>
		</div>
		<div class="card-body">
			<p>
				Les <code>Validators</code> sont des fonctions qui permettent de valider les valeurs des contr√¥les de formulaire. Ils
				peuvent √™tre utilis√©s pour v√©rifier si un champ est requis, si une valeur est valide ou si elle respecte un certain format.
			</p>
			<p>Exemples de validateurs:</p>
			<ul>
				<li><code>Validators.required</code> : V√©rifie que le champ n'est pas vide.</li>
				<li><code>Validators.email</code> : V√©rifie que la valeur est une adresse email valide.</li>
				<li><code>Validators.minLength</code> : V√©rifie que la longueur minimale est respect√©e.</li>
				<li><code>Validators.maxLength</code> : V√©rifie que la longueur maximale est respect√©e.</li>
				<li>Et bien plus dans la <a href="https://angular.dev/api/forms/Validators" target="_blank">doc</a>!</li>
			</ul>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
// Formulaire de contact
contactForm = this._fb.group({
  email: new FormControl("", [Validators.required, Validators.email]),
  firstName: this._fb.control("", [Validators.required, Validators.minLength(2)]),
  lastName: ["", [Validators.required, Validators.minLength(2)]],
});
			</textarea
			>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>Validation de champs</h2>
		</div>
		<div class="card-body">
			<p>
				Il est toujours pr√©f√©rable de donn√© un retour √† l'utlisateur directement apr√®s qu'il ait finit d'√©crire dans un champ que
				d'attendre la fin du formulaire pour savoir si quelque chose est mal remplit.
			</p>
			<p>
				Pour cela, nous allons utiliser la propri√©t√© <code>touched</code> et <code>valid</code> de notre <code>FormControl</code>.
				Cette propri√©t√© indique si l'utilisateur a interagi avec le champ ou non. Si l'utilisateur a interagi avec le champ et que
				le champ est invalide, nous pouvons afficher un message d'erreur.
			</p>
			<p>A la suite de chacun des champs, nous allons ajouter cette validation, voici un exemple pour le champ email:</p>
			<textarea highlight-js [options]="{}" [lang]="'html'">
<div>
  <label for="email">Email</label>
  <input id="email" type="text" formControlName="email" placeholder="Email" />
  @if (contactForm.get("email")?.touched && !contactForm.get("email")?.valid) {
    <p class="error">The email is required!</p>
  }
</div>
			</textarea
			>
			<p>
				Si le champ a √©t√© <code>touched</code> (donc si on a au moins cliqu√© dessus) et si le champ est invalide, on affiche le
				message d'erreur.
			</p>
			<p>
				üîé Note: pour savoir l'√©tat du champs nous devons utiliser
				<code>contactForm.get("nomDeLaProprieteDuFormGroup")</code> pour r√©cup√©rer le <code>FormControl</code> et ensuite avoir
				acc√®s √† son √©tat. <i>Il existe d'autres mani√®res de faire mais c'est √† vous de les creus√©s!</i>
			</p>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>Validation du formulaire</h2>
		</div>
		<div class="card-body">
			<p>
				Tout comme les champs (<code>FormControl</code>), le <code>FormGroup</code> poss√®de des √©tats pour savoir si le formulaire
				est valide (ou invalide).
			</p>
			<p>Rien de compliqu√© √† utiliser :<code>contactForm.valid</code> ou <code>contactForm.invalid</code></p>
			<p>
				Par exemple dans l'HTML on peut d√©sactiver le bouton "Send" tant que le formulaire n'est pas valide:
				<textarea highlight-js [options]="{}" [lang]="'html'">
<button type="submit" [disabled]="contactForm.invalid">Send</button>
				</textarea
				>
			</p>
			<i
				>üîé le <code>FormGroup</code> poss√®de d'autres
				<a href="https://angular.dev/api/forms/FormGroup" target="_blank"> informations int√©ressante üöÄ</a></i
			>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>R√©cup√©ration des donn√©es</h2>
		</div>
		<div class="card-body">
			<p>Une fois que le formulaire est valid√©, nous pouvons soumettre les donn√©es via un Event Binding :</p>
			<p>Pour r√©cup√©rer les donn√©es, utilisez la propri√©t√© value du FormGroup :</p>
			<p>Dans le fichier TS on va pr√©parer une m√©thode qui se lancera quand l'√©venement <code>submit</code> sera d√©clencher:</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
onSubmit() {
  if (this.contactForm.valid) {
    console.log("Form Submitted!", this.contactForm.value);
  } else {
    console.log("Form is invalid");
  }
}
			</textarea
			>
			<p>
				Dansle fichier HTML, nous alli√© notre m√©thode √† l'√©venement <code>ngSubmit</code>:
				<textarea highlight-js [options]="{}" [lang]="'html'">
<form [formGroup]="contactForm" (ngSubmit)="onSubmit()">
				</textarea
				>
			</p>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>Form Array</h2>
		</div>
		<div class="card-body">
			<p>
				Le type <code>FormArray</code> repr√©sente une collection de FormControl et permet de g√©rer dynamiquement des contr√¥les de
				formulaire. Vous pouvez l'utiliser si vous ne connaissez pas √† l'avance le nombre de contr√¥les.
			</p>

			<h3>Mise en place dans le fichier TS</h3>
			<ol>
				<li>
					<p>
						<strong>Pr√©paration du FormArray</strong>: on va commencer par instantier le <code>FormArray</code> et l'assigner au
						formulaire
					</p>
					<textarea highlight-js [options]="{}" [lang]="'typescript'">
// addreses du formulaire de contact
addresses = this._fb.array([ // 1. instantion du FormArray
  this._fb.group({
    street: ["", [Validators.required]],
    city: ["", [Validators.required]],
  }),
]);

contactForm = this._fb.group({
  email: new FormControl("", [Validators.required, Validators.email]),
  firstName: this._fb.control("", [
    Validators.required,
    Validators.minLength(2),
  ]),
  lastName: ["", [Validators.required, Validators.minLength(2)]],
  addresses: this.addresses, // 2. ajout du FormArray au FormGroup
});
					</textarea
					>
				</li>
				<li>
					<p>
						<strong>Ajout d'un FormGroup</strong>: on va cr√©er une m√©thode qui va nous permettre d'ajouter un
						<code>FormGroup</code> dans le <code>FormArray</code>
					</p>
					<textarea highlight-js [options]="{}" [lang]="'typescript'">
addAddress() {
  this.addresses.push(
    this._fb.group({
      street: ["", [Validators.required]],
      city: ["", [Validators.required]],
    }),
  );
}
					</textarea
					>
				</li>

				<li>
					<p>
						<strong>Suppression d'un FormGroup</strong>: on va cr√©er une m√©thode qui va nous permettre de supprimer un
						<code>FormGroup</code> dans le <code>FormArray</code>
					</p>
					<textarea highlight-js [options]="{}" [lang]="'typescript'">
removeAddress(index: number) {
  if (index > 0) {
    this.addresses.removeAt(index);
  }
}
					</textarea
					>
				</li>

				<li>
					<p><strong>Utilisation du FormArray dans l'HTML</strong>: en rajoutant dans la balise <code>form</code> existante:</p>
					<textarea highlight-js [options]="{}" [lang]="'html'">
  @for (address of addresses.controls; track $index) {
    <div [formGroup]="address">
      <div>
        <label for="street">Street:</label>
        <input id="street" type="text" formControlName="street" placeholder="Street" />
        @if (address.get("street")?.touched && !address.get("street")?.valid) {
          <p class="error">The street is required!</p>
        }
      </div>
      <div>
        <label for="city">City:</label>
        <input id="city" type="text" formControlName="city" placeholder="City" />
        @if (address.get("city")?.touched && !address.get("city")?.valid) {
          <p class="error">The city is required!</p>
        }
      </div>
      @if ($index > 0) {
        <button type="button" (click)="removeAddress($index)">Remove</button>
      }
    </div>
  }
<button type="button" (click)="addAddress()">Add Address</button>
  					</textarea
					>
					<p>üîéAnalyse du code:</p>
					<ul>
						<li>
							On va faire une boucle sur les controleur de la variable <code>addresses</code> qui est un
							<code>FormArray</code>.
						</li>
						<li>
							√âtant donn√© que <code>addresses</code> est un tableau de <code>FormGroup</code>, on va utiliser
							<code>formGroup</code> pour lier chaque <code>FormGroup</code> √† un <code>div</code>.
						</li>
						<li>
							On va ajouter chaque <code>input</code> pour chacune des propri√©t√©s du <code>FormGroup</code> (comme si c'√©tait
							un champ normal)
						</li>
						<li>On va rajouter un bouton pour supprimer le <code>FormGroup</code> en question</li>
						<li>On va rajouter un bouton pour ajouter un nouveau <code>FormGroup</code> √† la fin du tableau</li>
					</ul>
				</li>
			</ol>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>Validator custom</h2>
		</div>
		<div class="card-body">
			<p>TODO</p>
		</div>
	</article>
</section>
