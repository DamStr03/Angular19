<theory-header chapterName="Signal" />
<section class="card-body">
	<article class="card">
		<div class="card-header">
			<h2>Qu'est-ce que <code>Signal</code>?</h2>
		</div>
		<div class="card-body">
			<p>
				En Angular, un <strong>signal</strong> est un objet qui encapsule une valeur et permet de notifier automatiquement toutes
				les parties de l'application qui utilisent cette valeur lorsqu'elle change. Gr√¢ce aux signaux, il devient beaucoup plus
				simple de r√©agir aux modifications d'√©tat.
			</p>

			<p>
				Un signal peut contenir <strong>n'importe quel type de donn√©e</strong> : un nombre, une cha√Æne de caract√®res, un objet, un
				tableau, etc.
			</p>

			<p>
				Pour acc√©der √† la valeur d'un signal, il suffit d'appeler sa fonction d'acc√®s (getter). Cette m√©thode permet √† Angular de
				<strong>savoir automatiquement o√π la valeur est utilis√©e</strong>, afin de mettre √† jour uniquement les parties concern√©es
				de l'interface utilisateur.
			</p>

			<p>Il existe deux types de signaux :</p>

			<ul>
				<li><strong>Les signaux modifiables (writable)</strong> : vous pouvez modifier leur valeur directement.</li>
				<li>
					<strong>Les signaux en lecture seule (read-only)</strong> : ils exposent uniquement la lecture de leur valeur, sans
					possibilit√© de modification directe.
				</li>
			</ul>
		</div>
	</article>
	<article class="card">
		<div class="card-header">
			<h2>Writable signals</h2>
		</div>
		<div class="card-body">
			<p>
				Un <strong>signal modifiable</strong> est un type de signal dont la valeur peut √™tre
				<strong>mise √† jour directement</strong> gr√¢ce √† une API simple fournie par Angular.
			</p>
			<p>
				Pour cr√©er un signal modifiable, il suffit d'utiliser la fonction <code>signal()</code> en lui passant une
				<strong>valeur initiale</strong>. Cette valeur repr√©sente l'√©tat de d√©part que le signal va contenir.
			</p>

			<p>
				Une fois le signal cr√©√©, vous pouvez <strong>modifier sa valeur</strong> en utilisant la m√©thode <code>set()</code>. Cette
				m√©thode prend en param√®tre la nouvelle valeur que vous souhaitez attribuer au signal. <br />
				Ou en utilisant <code>.update()</code> pour calculer la nouvelle valeur √† partir de l'ancienne.
			</p>

			<textarea highlight-js [options]="{}" [lang]="'typescript'">
import {Component, OnInit, signal} from "@angular/core";
import {DemoHeaderComponent} from "@app/features/demo/components/layout/demo-header/demo-header.component";

@Component({
  selector: "demo-signal",
  imports: [DemoHeaderComponent],
  templateUrl: "./demo-signal.component.html",
  styleUrl: "./demo-signal.component.scss",
})
export class DemoSignalComponent implements OnInit {
  count = signal(0); // Cr√©ation d'un signal modifiable avec une valeur initiale de 0

  ngOnInit() {
    this.count.set(5); // Mise √† jour de la valeur du signal

    count.update((prev) => prev + 1); // Incr√©mente la valeur du signal de 1
  }
}
			</textarea
			>

			<p>Pour afficher la valeur du signal dans l'HTML:</p>
			<textarea highlight-js [options]="{}" [lang]="'html'">
<p>La valeur de la variable <code>count</code> est de: &#123;&#123; count() &#125;&#125;</p>
			</textarea
			>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>Computed Signals</h2>
		</div>
		<div class="card-body">
			<p>
				Un <strong>computed signal</strong> (signal calcul√©) est un <strong>signal en lecture seule</strong> dont la valeur est
				d√©riv√©e d'autres signaux.<br />
				On d√©finit un signal calcul√© √† l'aide de la fonction computed(), en pr√©cisant une fonction qui d√©crit comment obtenir la
				valeur d√©riv√©e.
			</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
count = signal(2); // Cr√©ation d'un signal modifiable avec une valeur initiale de 2

// Cr√©ation d'un signal calcul√© qui double la valeur du signal count
doubleCount: Signal<number> = computed(() => this.count() * 2);
		</textarea
			>
			<p>Dans cet exemple:</p>
			<ul>
				<li><code>doubleCount</code> d√©pend de <code>count</code>.</li>
				<li>
					√Ä chaque fois que <code>count</code> est mis √† jour, Angular sait automatiquement que <code>doubleCount</code>
					doit aussi √™tre recalcul√©.
				</li>
			</ul>

			<hr />

			<p>Les computed signals sont √©valu√©s <strong>paresseusement</strong> et <strong>m√©moris√©s</strong></p>
			<ul>
				<li>
					<strong>Paresseux (lazy)</strong> : La fonction de d√©rivation (<code>count() * 2</code>) ne s'ex√©cute que lors de la
					premi√®re lecture de <code>doubleCount</code>.
				</li>
				<li>
					<strong>M√©moris√©s (memoized)</strong> : Apr√®s le premier calcul, la valeur est mise en cache. Tant que
					<code>count</code> ne change pas, toute nouvelle lecture de <code>doubleCount</code> retourne simplement la valeur en
					cache, <strong>sans recalcul</strong>.
				</li>
			</ul>

			<p>
				D√®s que <code>count</code> est modifi√©, Angular invalide la valeur en cache de <code>doubleCount</code>, et le prochain
				acc√®s recalculera la bonne valeur.
				<i
					>üîé Cela permet de r√©aliser des calculs co√ªteux (par exemple, des tris ou filtres sur de gros tableaux) de mani√®re
					efficace avec des computed().
				</i>
			</p>

			<hr />
			<p><strong>Les d√©pendances d'un computed signal sont dynamiques</strong></p>
			<p>
				Angular <strong>piste uniquement</strong> les signaux effectivement <strong>lus</strong> pendant l'ex√©cution de la fonction
				de d√©rivation. Exemple plus avanc√© : typescript Copier Modifier
			</p>

			<p>Exemple plus avanc√©:</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
const showCount = signal(false);
const count = signal(0);

const conditionalCount = computed(() => {
  if (showCount()) {
    return `Le compteur est √† ${count()}.`;
  } else {
    return 'Rien √† afficher !';
  }
});
			</textarea
			>
			<p>Que se passe-t-il ici ?</p>
			<ul>
				<li>Si <code>showCount</code> vaut <code>false</code>, la fonction ne lit pas <code>count</code>().</li>
				<li>Donc, modifier <code>count</code> <strong>ne d√©clenchera pas</strong> de recalcul de <code>conditionalCount</code>.</li>
				<li>
					Si <code>showCount</code> passe √† <code>true</code> et que vous lisez <code>conditionalCount</code>, alors cette fois
					<code>count</code> <strong>devient une d√©pendance</strong>.
				</li>
				<li>
					Plus tard, si <code>showCount</code> repasse √† <code>false</code>, <code>count</code> <strong>sera retir√©</strong> des
					d√©pendances.
				</li>
			</ul>
			<i>üîé Angular ajuste donc automatiquement la liste des d√©pendances √† chaque ex√©cution du computed().</i>
		</div>
	</article>

	<article class="card">
		<div class="card-header">
			<h2>Effects</h2>
		</div>
		<div class="card-body">
			<p>
				Les <strong>signals</strong> sont puissants parce qu'ils notifient automatiquement les parties int√©ress√©es lorsqu'ils
				changent. Un <strong>effect</strong> (effet) est une op√©ration qui <strong>s'ex√©cute automatiquement</strong> d√®s qu'une ou
				plusieurs valeurs de signaux changent.
			</p>
			<p>Pour cr√©er un effet, on va utiliser la fonction <code>effect()</code></p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
effect(() => {
  console.log(`Le compteur actuel est : ${count()}`);
});
			</textarea
			>
			<p>üîé √Ä retenir:</p>
			<ul>
				<li>Un effect <strong>s'ex√©cute toujours au moins une fois</strong> d√®s sa cr√©ation.</li>
				<li>Lors de son ex√©cution, Angular <strong>piste</strong> tous les signaux utilis√©s dans le callback.</li>
				<li>Si l'un de ces signaux change, l'effect sera <strong>rejou√© automatiquement</strong>.</li>
				<li>
					Comme pour les <code>computed()</code>, les <strong>d√©pendances sont dynamiques</strong> : seuls les signaux lus √† la
					derni√®re ex√©cution sont suivis.
				</li>
			</ul>
			<p>
				üîé <strong>Particularit√© importante : </strong>Les effects s'ex√©cutent <strong>asynchrone</strong>
				pendant le
				<strong>cycle de d√©tection des changements</strong> d'Angular.
			</p>
			<hr />

			<h3>Quand utiliser un <code>Effect</code>?</h3>
			<p>
				Les effects sont raresment n√©cessaires dans du code d'application classique, mais ils sont tr√®s utiles dans certains cas
				particuliers, notamment :
			</p>
			<ul>
				<li>üîé Faire du logging (journaliser) des donn√©es affich√©es et suivre leurs changements pour du debug ou de l'analyse.</li>
				<li>üîÑ Synchroniser des donn√©es avec window.localStorage.</li>
				<li>
					üõ†Ô∏è Ajouter des comportements DOM personnalis√©s qui ne peuvent pas √™tre exprim√©s avec la syntaxe du template Angular.
				</li>
				<li>
					üìà Effectuer des rendus personnalis√©s sur un <code> &#60;canvas&#62; </code>, un <strong>graphe</strong>, ou une
					<strong>librairie graphique tierce</strong>.
				</li>
			</ul>

			<hr />

			<h3>Quand <strong>ne pas</strong> utiliser un <code>Effect</code>?</h3>
			<p><strong>‚ùó Ne pas utiliser</strong> d'effet pour <strong>propager des changements d'√©tat</strong> entre signaux.</p>
			<p>Cela peut provoquer:</p>
			<ul>
				<li>Des erreurs du type <code>ExpressionChangedAfterItHasBeenChecked</code></li>
				<li>Des <strong>boucles infinies</strong></li>
				<li>Des <strong>performances d√©grad√©es</strong></li>
			</ul>
			<p>üëâ Utilisez plut√¥t des <code>computed()</code> pour mod√©liser des √©tats d√©pendants les uns des autres.</p>

			<hr />
			<h3>Contexte d'injection (Injection Context)</h3>
			<p>
				Par d√©faut, vous ne pouvez appeler <code>effect()</code>
				<strong>que dans un contexte d'injection Angular</strong> (c‚Äôest-√†-dire l√† o√π inject() est disponible).
			</p>
			<p>
				Le plus simple est donc d'utiliser <code>effect()</code> directement dans le <strong>constructeur d'un composant</strong>,
				d'une <strong>directive</strong> ou d'un <strong>service</strong> :
			</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
@Component({...})
export class EffectiveCounterComponent {
  readonly count = signal(0);

  constructor() {
    effect(() => {
      console.log(`Le compteur est : ${this.count()}`);
    });
  }
}
			</textarea
			>
			<p>Vous pouvez aussi assigner l'effect √† un champ priv√© pour lui donner un nom descriptif :</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
@Component({...})
export class EffectiveCounterComponent {
  readonly count = signal(0);

  private loggingEffect = effect(() => {
    console.log(`Le compteur est : ${this.count()}`);
  });
}
			</textarea
			>
			<p>Si vous devez cr√©er un effect <strong>hors du constructeur</strong>, vous pouvez lui passer un <code>Injector</code>:</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
@Component({...})
export class EffectiveCounterComponent {
  readonly count = signal(0);
  private injector = inject(Injector);

  initializeLogging(): void {
    effect(() => {
      console.log(`Le compteur est : ${this.count()}`);
    }, { injector: this.injector });
  }
}
			</textarea
			>

			<hr />
			<h3>Destruction d'un Effect</h3>
			<p>
				‚úÖ Quand vous cr√©ez un effect, il est automatiquement <strong>d√©truit</strong> en m√™me temps que son contexte (par exemple √†
				la destruction du composant).
			</p>
			<p>Vous pouvez aussi d√©truire manuellement un effect :</p>
			<p>
				Chaque appel √† <code>effect()</code> retourne un <code>EffectRef</code>, qui poss√®de une m√©thode <code>.destroy()</code> :
			</p>
			<textarea highlight-js [options]="{}" [lang]="'typescript'">
const myEffect = effect(() => {
  // ...
});

myEffect.destroy(); // D√©truire l'effet manuellement
			</textarea
			>
			<p>
				Dans certains cas sp√©cifiques, vous pouvez aussi utiliser l'option manualCleanup pour contr√¥ler manuellement la dur√©e de vie
				d'un effect. <br />
				<strong> ‚ö†Ô∏èÔ∏è Attention</strong> : il faut absolument <strong>nettoyer</strong> les effects manuels pour √©viter des
				<strong>fuites m√©moire</strong> !
			</p>
		</div>
	</article>
</section>
